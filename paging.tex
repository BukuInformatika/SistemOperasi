\section SISTEM PAGING
Sistem Paging Adalah sistem manajemen pada sistem operasi dalam mengatur program yang sedang berjalan. Program yang berjalan harus dimuat di memori utama. Kendala yang terjadi apabila suatu program lebih besar dibandingkan dengan memori utama yang tersedia.

Untuk mengatasi hal tersebut Sistem Paging mempunyai 2 solusi, yaitu:

\subsection Konsep Overlay
Dimana program yang dijalankan dipecah menjadi beberapa bagian yang dapat dimuat memori (overlay). Overlay yang belum diperlukan pada saat program berjalan (tidak sedang di eksekusi) disimpan di disk, dimana nantinya overlay tersebut akan dimuat ke memori begitu diperlukan dalam eksekusinya.
<<<<<<< HEAD
- Konsep Memori Maya (virtual Memory)
Adalah kemampuan mengalamati ruang memori melebihi memori utama yang tersedia. Konsep ini pertama kali dikemukakan Fotheringham pada tahun 1961 untuk sistem komputer Atlas di Universitas Manchester, Inggris.

Gagasan Memori Maya adalah ukuran gabungan program, data dan stack melampaui jumlah memori fisik yang tersedia. Sistem operasi menyimpan bagian-bagian proses yang sedang digunakan di memori utama dan sisanya di disk. Begitu bagian di disk diperlukan maka bagian memori yang tidak diperlukan disingkirkan dan diganti bagian disk yang diperlukan.
=======

<<<<<<< HEAD

\section Masalah Penggantian Halaman
disini punya mu ham

Berdasarkan pertimbangan tersebut, sebenarnya proses-proses yang memiliki 10 halaman hanya akan menggunakan setengah dari jumlah seluruh halaman yang dimilikinya. Kemudian demand paging akan menyimpan I/O yang dibutuhkan untuk mengisi 5 halaman yang belum pernah digunakan. Kita juga dapat meningkatkan derajat multiprogramming dengan menjalankan banyak proses sebanyak 2 kali.

Jika kita meningkatkan derajat multiprogramming, itu sama artinya dengan melakukan over-allocating terhadap memori
=======
\section sistem paging 
pengertian sistem paging 
Sistem Paging Merupakan sistem yang memanajemen pada sistem operasi dalam mengelola program program yang sedang berjalan. Program program yang berjalan harus dimuat didalam memori utama. Batasan batasan yang terjadi saat program lebih besar dari memori utama yang telah tersedia.

\subsection pembagian solusi sistem paging 
<<<<<<< HEAD
a.Konsep Overlay
b.Konsep Memori Maya (virtual Memory)


\section Masalah Penggantian Halaman
 
Pada dasarnya, kesalahan halaman (page fault) sudah tidak lagi menjadi masalah yang terlalu  dianggap serius. Hal ini disebabkan karena masing-masing halaman pasti akan mengalami paling tidak satu kali kesalahan dalam pemberian halaman, yakni ketika halaman ini ditunjuk untuk pertama kalinya. Representasi seperti ini sebenarnya tidaklah terlalu akurat. 
=======
a. Konsep Overlay
Dimana program yang dijalankan dipecah menjadi beberapa bagian yang dapat dimuat memori (overlay). Overlay yang belum diperlukan pada saat program berjalan (tidak sedang di eksekusi) disimpan di disk, dimana nantinya overlay tersebut akan dimuat ke memori begitu diperlukan dalam eksekusinya.

b. Konsep Memori Maya (virtual Memory)
Adalah kemampuan mengalamati ruang memori melebihi memori utama yang tersedia. Konsep ini pertama kali dikemukakan Fotheringham pada tahun 1961 untuk sistem komputer Atlas di Universitas Manchester, Inggris.

\section penggantian page 
Pada dasarnya, kesalahan halaman tidak lagi menjadi masalah serius. Ini karena setiap halaman akan mengalami setidaknya satu kesalahan dalam pengiriman halaman, yaitu ketika halaman ini ditujukan untuk pertama kalinya. Representasi seperti ini sebenarnya tidak terlalu akurat. Berdasarkan pertimbangan ini, sebenarnya proses yang memiliki 10 halaman hanya akan menggunakan setengah dari jumlah total halaman yang dimilikinya. Kemudian permintaan paging akan menyimpan I / O yang diperlukan untuk mengisi 5 halaman yang belum pernah digunakan. Kami juga dapat meningkatkan tingkat multiprogramming dengan menjalankan beberapa proses 2 kali.

Jika kita meningkatkan derajat multiprogramming, itu sama artinya dengan melakukan over-allocating terhadap memori. Jika kita menjalankan 6 proses, dengan masing-masing mendapatkan 10 halaman, walau pun sebenarnya yang digunakan hanya 5 halaman, kita akan memiliki utilisasi CPU dan throughpsZsut yang lebih tinggi dengan 10 frame yang masih kosong.

<<<<<<< HEAD
Lebih jauh lagi, kita harus mempertimbangkan bahwa sistem memori tidak hanya digunakan untuk menangani pengalamatan suatu program. Penyangga (buffer) untuk I/O juga menggunakan sejumlah memori. Penggunaan ini dapat meningkatkan pemakaian algoritma dalam penempatan di memori.

Beberapa sistem mengalokasikan secara pasti beberapa persen dari memori yang dimilikinya untuk penyangga I/O, dimana keduanya, baik proses

=======
Lebih jauh lagi, kita harus mempertimbangkan bahwa sistem memori tidak hanya digunakan untuk menangani pengalamatan suatu program. Buffer untuk I / O juga menggunakan beberapa memori. Penggunaan ini dapat meningkatkan penggunaan algoritma dalam penempatan di memori.
Beberapa sistem mengalokasikan persis beberapa persen dari memori mereka untuk menyangga I / O, di mana keduanya,


>>>>>>> bb5b1b8fb5ec356edc5fac3a7fdb84aeb4100dc3

Beberapa sistem mengalokasikan tepat beberapa persen dari memori mereka untuk buffer I / O, keduanya, baik proses pengguna dan subsistem I / O race untuk mengambil keuntungan dari seluruh sistem memori.

\section skema dasar pemindahan halaman 
Pemindahan halaman menggunakan pendekatan berikut. Jika tidak ada frame yang kosong, kami mencari frame yang tidak digunakan dan mengosongkannya. Kita dapat mengosongkan bingkai dengan menulis isinya ke dalam ruang swap, dan mengubah tabel halaman (serta tabel lainnya) untuk menunjukkan bahwa halaman tidak akan lama dalam memori.
>>>>>>> d2adb95ac32c341dbf4c06f719cc40907625cc41

\subsection cara memindahkan halaman
1. Cari lokasi dari halaman yang diinginkan pada disk

2. Cari frame kosong

a. Jika ada frame kosong, gunakan.
b. Jika tidak ada frame kosong, gunakan algoritma pemindahan halaman untuk menyeleksi frame yang akan digunakan.
c. Tulis halaman yang telah dipilih ke disk, ubah tabel halaman dan tabel frame.

3. Baca halaman yang diinginkan kedalam frame kosong yang baru, ubah tabel halaman dan tabel frame
 
4. Ulang dari awal proses pengguna.

Jika tidak ada frame yang kosong, pentransferan dua halaman (satu masuk, satu keluar) akan dilakukan. Situasi ini secara efektif akan menggandakan waktu pelayanan kesalahan halaman dan meningkatkan waktu akses efektif. Kita dapat mengurangi pemborosan ini dengan menggunakan bit tambahan. Masingmasing halaman atau frame mungkin memiliki bit tambahan yang diasosiasikan didalam perangkat keras. Pemindahan halaman merupakan dasar dari demand paging. Yang menjembatani pemisahan antara memori lojik dan memori fisik. Dengan mekanisme seperti ini, memori virtual yang sangat besar dapat disediakan untuk programmer dalam bentuk memori fisik yang lebih kecil. Dengan nondemand paging, alamat dari user dipetakan kedalam alamat fisik, jadi 2 set alamat dapat berbeda. Seluruh halaman dari proses masih harus berada di memori fisik. Dengan demand paging, ukuran dari ruang alamat logika sudah tidak dibatasi oleh memori fisik.
Kita harus menyelesaikan 2 masalah utama untuk mengimplementasikan demand paging. Kita harus  mengembangkan algoritma pengalokasian rame dan algoritma pemindahan halaman. Jika kita memiliki banyak proses di memori, kita harus memutuskan berapa banyak frame yang akan dialokasikan ke masing-masing proses. Lebih jauh lagi, saat pemindahan halaman diinginkan, kita harus memilih frame yang akan dipindahkan. Membuat suatu algoritma yang tepat untuk menyelesaikan masalah ini adalah hal yang sangat penting.
ini adalah hal yang sangat penting.

Ada beberapa algoritma pemindahan halaman yang berbeda. Kemungkinan setiap Sistem Operasi memiliki skema pemindahan yang unik. Algoritma pemindahan yang baik adalah yang memiliki tingkat kesalahan halaman terendah. Kita mengevaluasi algoritma dengan menjalankanny dalam string khusus di memori acuan dan menghitung jumlah kesalahan halaman.  String dari memori acuan disebut string acuan (reference string). Sebagai contoh, jika kita memeriksa proses khusus, kita mungkin akan mencatat urutan alamat seperti dibawah ini:
0100, 0432, 0101, 0612, 0102, 0103, 0104, 0101, 0611, 0102, 0103, 0104, 0101, 0610, 0102, 0103,

0104, 0101, 0609, 0102, 0105, di mana pada 100 byte per halaman, diturunkan menjadi string referensi sebagai berikut:

1, 4, 1, 6, 1, 6, 1, 6, 1, 6, 1 

Perhatikan bahwa selama jumlah frame meningkat, jumlah kesalahan halaman menurun.

Penambahan memori fisik akan menambah jumlah frame.

<<<<<<< HEAD
\section Pemindahan Halaman Secara FIFO

Algoritma ini adalah algoritma paling sederhana dalam hal pemindahan halaman. Algoritma pemindahan
 
FIFO (First In First Out) mengasosiasikan waktu pada saat halaman dibawa kedalam memori dengan masing-masing halaman. Pada saat halaman harus dipindahkan, halaman yang paling tua yang dipilih.

Sebagai contoh:
\subsection
Gambar 4-11. String Acuan. Sumber: . . .



=======
Pemindahan Halaman Secara FIFO
>>>>>>> 7018814d0ceaa7fe1ac2eb3131052e52feeef48f

Algoritma ini adalah algoritma paling sederhana dalam hal pemindahan halaman. Algoritma pemindahan
 
FIFO (First In First Out) mengasosiasikan waktu pada saat halaman dibawa kedalam memori dengan masing-masing halaman. Pada saat halaman harus dipindahkan, halaman yang paling tua yang dipilih.

Sebagai contoh:
Gambar 4-11. String Acuan. Sumber: . . .

7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1

7 7 7 2 2 2 4 4 4 0 0 0 7 7 7

0 0 0 3 3 3 2 2 2 1 1 1 0 0

1 1 1 0 0 0 3 3 3 2 2 2 1

Dari contoh contoh di atas, ada 15 halaman kesalahan. Algoritma FIFO mudah dimengerti dan diimplementasikan. Namun kinerjanya tidak selalu baik. Salah satu kelemahan dari algoritma FIFO adalah kemungkinan anomali Beladi, yang ada dalam beberapa kasus, tingkat kesalahan akan meningkat apabila jumlah frame yang dialokasikan juga meningkat.

\section pemindahan halaman secara optimal 
Salah satu konsekuensi mencegah anomali Beladi adalah algoritma pergerakan halaman yang optimal. Algoritma ini memiliki tingkat kesalahan halaman terendah dibandingkan dengan algoritma lainnya. Algoritma ini tidak akan mengalami anomali Belady. Konsep utama dari algoritma ini adalah mengganti halaman yang tidak akan digunakan untuk periode waktu terlama. Algoritma ini memastikan tingkat kesalahan serendah mungkin untuk sejumlah frame yang tetap.

\subsection Perlu disayangkan, algoritma optimal susah untuk diimplementasikan kedalam program, karena algoritma ini menuntut pengetahuan tentang string acuan yang akan muncul.

\section Pemindahan Halaman Secara LRU

Jika algoritma optimal sulit untuk dilakukan, mungkin kita dapat melakukan pendekatan terhadap algoritma tersebut. Jika kita menggunakan waktu yang baru berlalu sebagai pendekatan terhadap waktu yang akan datang, 

\subsection
(Least Recently Used) Rekan algoritma LRU dengan setiap halaman waktu dari halaman yang terakhir digunakan. Ketika halaman harus dipindahkan, LRU memilih halaman terpakai terpanjang di masa lalu. Berikut adalah algoritma LRU, lihat waktu lampau, bukan waktu yang akan datang.

Untuk mengimplementasikan algoritma LRU, ada 2 implementasi yang dapat digunakan, yaitu dengan counter dan stack. Selain algoritma optimal, algoritma LRU juga dapat menghindari anomali Beladi. Salah satu kelas algoritma halaman bergerak adalah algoritma tumpukan, yang juga tidak akan pernah mengalami anomali Beladi. Algoritma tumpukan ini menyimpan nomor halaman pada tumpukan. Kapan pun suatu halaman ditunjuk, halaman ini dikeluarkan dari tumpukan dan diletakkan di blok paling atas dari tumpukan. Dengan cara seperti ini, blok paling atas dari tumpukan selalu berisi halaman yang baru digunakan, sedangkan blok terbawah dari tumpukan selalu berisi halaman yang sudah lama tidak digunakan. Karena suatu halaman dalam tumpukan dapat dikeluarkan meski pun berada ditengah-tengah 