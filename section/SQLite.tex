\section{Cara insert SQLite}
	\subsection{Definisi}
		\begin{enumerate}
			\item SQLite adalah sistem manajemen basis data relasional yang terkandung dalam pustaka pemrograman C. Tidak seperti banyak sistem manajemen basis data lainnya, SQLite bukan mesin basis data client-server. Semuanya, dicetak dalam program terakhir.
			\item SQLite adalah ACID-compliant dan mengimplementasikan sebagian besar standar SQL, menggunakan sintaks SQL dinamis dan yang tidak dapat menjamin integritas domain..
		\end{enumerate}
	\subsection{Sejarah}
		\begin{enumerate}
			\item D. Richard Hipp mendesain SQLite pada musim semi tahun 2000 ketika bekerja untuk General Dynamics dalam kontrak dengan Angkatan Laut Amerika Serikat. Hipp merancang perangkat lunak yang digunakan pada kapal perusak rudal, yang semula menggunakan HP-UX dengan database back-end IBM Informix. SQLite dimulai sebagai ekstensi Tcl.
			\item Tujuan desain dari SQLite adalah untuk memungkinkan program untuk beroperasi tanpa menginstal sistem manajemen basis data atau membutuhkan administrator basis data. Hipp berdasarkan sintaks dan semantik pada PostgreSQL 6.5. Pada bulan Agustus 2000, versi 1.0 dari SQLite dirilis, dengan penyimpanan berdasarkan gdbm (GNU Database Manager). SQLite 2.0 menggantikan gdbm dengan implementasi B-tree khusus, menambahkan kemampuan transaksi. SQLite 3.0, sebagian didanai oleh America Online, menambahkan internasionalisasi, pengetikan manifes, dan peningkatan besar lainnya.
			\item Pada tahun 2011 Hipp mengumumkan rencana untuk menambahkan antarmuka NoSQL (mengelola dokumen yang dinyatakan dalam JSON) ke database SQLite dan mengembangkan UnQLite, database berorientasi dokumen yang dapat disematkan. UnQLite dirilis sebagai database independen.
		\end{enumerate}
	\subsection{Desain}
		\begin{enumerate}
			\item Tidak seperti sistem manajemen basis data client-server, mesin SQLite tidak memiliki proses mandiri yang digunakan aplikasi untuk berkomunikasi. Sebaliknya, pustaka SQLite terhubung dan dengan demikian menjadi bagian integral dari program aplikasi. Menautkan dapat berupa statis atau dinamis. Program aplikasi menggunakan fungsi SQLite melalui panggilan fungsi sederhana, yang mengurangi latensi dalam akses database: panggilan fungsi dalam satu proses lebih efisien daripada komunikasi antar-proses. SQLite menyimpan seluruh basis data (definisi, tabel, indeks, dan datanya sendiri) sebagai file lintas platform tunggal pada mesin host. Ini mengimplementasikan desain sederhana ini dengan mengunci seluruh file database saat menulis. Operasi baca SQLite dapat multitasked, meskipun menulis hanya dapat dilakukan secara berurutan.
			\item Karena desainnya tanpa server, aplikasi SQLite memerlukan lebih sedikit konfigurasi daripada database client-server. SQLite disebut nol-conf karena tidak memerlukan manajemen layanan (seperti skrip startup) atau kontrol akses berdasarkan GRANT dan kata sandi. Kontrol akses ditangani dengan cara izin sistem file yang diberikan ke file database itu sendiri. Database dalam sistem client-server menggunakan hak akses file sistem yang memberikan akses ke file database hanya ke proses daemon.
			\item Implikasi lain dari desain tanpa server adalah bahwa beberapa proses mungkin tidak dapat menulis ke file database. Dalam basis data berbasis server, beberapa penulis akan terhubung ke daemon yang sama, yang mampu menangani kunci secara internal. Di sisi lain, SQLite harus bergantung pada kunci sistem file. Ini memiliki sedikit pengetahuan tentang proses lain yang mengakses database pada saat yang bersamaan. Oleh karena itu, SQLite bukan pilihan yang lebih disukai untuk penyebaran intensif. Namun, untuk pertanyaan sederhana dengan sedikit konkurensi, keuntungan kinerja SQLite dari menghindari overhead yang meneruskan datanya ke proses lain.
			\item SQLite menggunakan PostgreSQL sebagai platform referensi. Apa yang akan dilakukan PostgreSQL digunakan untuk memahami standar SQL. Salah satu ketidakberesan utama adalah bahwa, dengan pengecualian kunci primer, SQLite tidak memaksakan jenis pemeriksaan; jenis nilai bersifat dinamis dan tidak dibatasi oleh skema (meskipun skema akan memicu konversi saat menyimpan, jika konversi semacam itu berpotensi reversibel). SQLite berusaha mengikuti Aturan Postel.
		\end{enumerate}
		
		\subsection{Syntax Perintah Insert}
\begin{verbatim}

INSERT INTO nama_tabel [(kolom1, kolom2, kolom3, … kolomn)]
VALUES (nilai1, nilai2, nilai3,… nilaiN);
Kolom1, kolom2, kolom3 merupakan nama kolom yang ada didalam tabel sqlite yang akan kamu tambahkan data kedalam masing masing kolom tersebut.

INSERT INTO nama_tabel VALUES (nilai1, nilai2, nilai3,… nilaiN);
Contoh Perintah Insert Di SQLite


INSERT INTO siswa (id, nama, umur, alamat)
VALUES (1, 'Firdan Ardiansyah',27,'JL. KH. Atim II');
INSERT INTO siswa (id, nama, umur, alamat)
VALUES (2, 'Muhammad Ammar',25,'BTN. Palaton');
INSERT INTO siswa (id, nama, umur, alamat)
VALUES (3, 'Bilal Ardiansyah',23,'BTN. Depag');
INSERT INTO siswa (id, nama, umur, alamat)
VALUES (4, 'Rafi Syabani',25,'BTN. Sumur Buang');

INSERT INTO siswa VALUES (5, 'Muhammad Bintang',23,'Pandeglang'); 
Melihat Data Didalam Tabel Siswa
\end{verbatim}


	\subsection{Melihat Data}
		\begin{verbatim}
SELECT * FROM siswa;
		\end{verbatim}
		