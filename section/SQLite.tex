\section{Cara insert SQLite}
	\subsection{Definisi}
		\begin{enumerate}
			\item SQLite adalah sistem manajemen basis data relasional yang terkandung dalam pustaka pemrograman C. Tidak seperti banyak sistem manajemen basis data lainnya, SQLite bukan mesin basis data client-server. Semuanya, dicetak dalam program terakhir.
			\item SQLite adalah ACID-compliant dan mengimplementasikan sebagian besar standar SQL, menggunakan sintaks SQL dinamis dan yang tidak dapat menjamin integritas domain..
		\end{enumerate}
	\subsection{Sejarah}
		\begin{enumerate}
			\item D. Richard Hipp mendesain SQLite pada musim semi tahun 2000 ketika bekerja untuk General Dynamics dalam kontrak dengan Angkatan Laut Amerika Serikat. Hipp merancang perangkat lunak yang digunakan pada kapal perusak rudal, yang semula menggunakan HP-UX dengan database back-end IBM Informix. SQLite dimulai sebagai ekstensi Tcl.
			\item Tujuan desain dari SQLite adalah untuk memungkinkan program untuk beroperasi tanpa menginstal sistem manajemen basis data atau membutuhkan administrator basis data. Hipp berdasarkan sintaks dan semantik pada PostgreSQL 6.5. Pada bulan Agustus 2000, versi 1.0 dari SQLite dirilis, dengan penyimpanan berdasarkan gdbm (GNU Database Manager). SQLite 2.0 menggantikan gdbm dengan implementasi B-tree khusus, menambahkan kemampuan transaksi. SQLite 3.0, sebagian didanai oleh America Online, menambahkan internasionalisasi, pengetikan manifes, dan peningkatan besar lainnya.
			\item Pada tahun 2011 Hipp mengumumkan rencana untuk menambahkan antarmuka NoSQL (mengelola dokumen yang dinyatakan dalam JSON) ke database SQLite dan mengembangkan UnQLite, database berorientasi dokumen yang dapat disematkan. UnQLite dirilis sebagai database independen.
		\end{enumerate}
	\subsection{Desain}
		\begin{enumerate}
			\item Tidak seperti sistem manajemen basis data client-server, mesin SQLite tidak memiliki proses mandiri yang digunakan aplikasi untuk berkomunikasi. Sebaliknya, pustaka SQLite terhubung dan dengan demikian menjadi bagian integral dari program aplikasi. Menautkan dapat berupa statis atau dinamis. Program aplikasi menggunakan fungsi SQLite melalui panggilan fungsi sederhana, yang mengurangi latensi dalam akses database: panggilan fungsi dalam satu proses lebih efisien daripada komunikasi antar-proses. SQLite menyimpan seluruh basis data (definisi, tabel, indeks, dan datanya sendiri) sebagai file lintas platform tunggal pada mesin host. Ini mengimplementasikan desain sederhana ini dengan mengunci seluruh file database saat menulis. Operasi baca SQLite dapat multitasked, meskipun menulis hanya dapat dilakukan secara berurutan.
			\item Karena desainnya tanpa server, aplikasi SQLite memerlukan lebih sedikit konfigurasi daripada database client-server. SQLite disebut nol-conf karena tidak memerlukan manajemen layanan (seperti skrip startup) atau kontrol akses berdasarkan GRANT dan kata sandi. Kontrol akses ditangani dengan cara izin sistem file yang diberikan ke file database itu sendiri. Database dalam sistem client-server menggunakan hak akses file sistem yang memberikan akses ke file database hanya ke proses daemon.
			\item Implikasi lain dari desain tanpa server adalah bahwa beberapa proses mungkin tidak dapat menulis ke file database. Dalam basis data berbasis server, beberapa penulis akan terhubung ke daemon yang sama, yang mampu menangani kunci secara internal. Di sisi lain, SQLite harus bergantung pada kunci sistem file. Ini memiliki sedikit pengetahuan tentang proses lain yang mengakses database pada saat yang bersamaan. Oleh karena itu, SQLite bukan pilihan yang lebih disukai untuk penyebaran intensif. Namun, untuk pertanyaan sederhana dengan sedikit konkurensi, keuntungan kinerja SQLite dari menghindari overhead yang meneruskan datanya ke proses lain.
			\item SQLite menggunakan PostgreSQL sebagai platform referensi. Apa yang akan dilakukan PostgreSQL digunakan untuk memahami standar SQL. Salah satu ketidakberesan utama adalah bahwa, dengan pengecualian kunci primer, SQLite tidak memaksakan jenis pemeriksaan; jenis nilai bersifat dinamis dan tidak dibatasi oleh skema (meskipun skema akan memicu konversi saat menyimpan, jika konversi semacam itu berpotensi reversibel). SQLite berusaha mengikuti Aturan Postel.
		\end{enumerate}
		
		\subsection{Syntax Perintah Insert}
\begin{verbatim}

INSERT INTO nama_tabel [(kolom1, kolom2, kolom3, … kolomn)]
VALUES (nilai1, nilai2, nilai3,… nilaiN);
Kolom1, kolom2, kolom3 merupakan nama kolom yang ada didalam tabel sqlite yang akan kamu tambahkan data kedalam masing masing kolom tersebut.

INSERT INTO nama_tabel VALUES (nilai1, nilai2, nilai3,… nilaiN);
Contoh Perintah Insert Di SQLite


INSERT INTO siswa (id, nama, umur, alamat)
VALUES (1, 'Firdan Ardiansyah',27,'JL. KH. Atim II');
INSERT INTO siswa (id, nama, umur, alamat)
VALUES (2, 'Muhammad Ammar',25,'BTN. Palaton');
INSERT INTO siswa (id, nama, umur, alamat)
VALUES (3, 'Bilal Ardiansyah',23,'BTN. Depag');
INSERT INTO siswa (id, nama, umur, alamat)
VALUES (4, 'Rafi Syabani',25,'BTN. Sumur Buang');

INSERT INTO siswa VALUES (5, 'Muhammad Bintang',23,'Pandeglang'); 
Melihat Data Didalam Tabel Siswa
\end{verbatim}


	\subsection{Melihat Data}
		\begin{verbatim}
SELECT * FROM siswa;
		\end{verbatim}
		
	\begin{figure}[ht]
		\centerline{\includegraphics[width=1\textwidth]{figures/Sql.png}}
		\caption{Hasilnya}
		\label{Sql}
	\end{figure}
	Gambar \ref{Sql} Hasil gambar.
	
	\subsection{Fiture}
		\begin{enumerate}
			\item SQLite mengimplementasikan sebagian besar standar SQL-92 untuk SQL tetapi tidak memiliki beberapa fitur. Misalnya, beberapa menyediakan pemicu, dan tidak dapat menulis ke tampilan (tetapi menyediakan pemicu INSTEAD OF yang menyediakan fungsi ini). Meskipun menyediakan query kompleks, masih memiliki fungsi ALTER TABLE terbatas, karena tidak dapat memodifikasi atau menghapus kolom.
			\item SQLite menggunakan sistem tipe yang tidak biasa untuk DBMS yang kompatibel dengan SQL: alih-alih menetapkan jenis ke kolom seperti pada kebanyakan sistem basis data SQL, mereka ditetapkan ke nilai individual: dalam bahasa yang diketik secara dinamis. Selain itu, itu lemah diketik dalam beberapa cara yang sama bahwa Perl adalah: satu dapat memasukkan string ke dalam kolom integer (meskipun SQLite akan mencoba untuk mengubah string ke integer pertama, jika jenis kolom yang diinginkan adalah bilangan bulat). Ini menambah fleksibilitas ke kolom, terutama ketika terikat ke bahasa scripting yang diketik secara dinamis. Namun, teknik ini tidak portabel untuk produk SQL lainnya. Kritik umum adalah bahwa sistem tipe SQLite tidak memiliki mekanisme integritas data yang disediakan oleh kolom-kolom yang diketik secara statis dalam produk lain. Situs web SQLite menggambarkan mode afinitas yang ketat, tetapi fitur ini belum ditambahkan. Namun, itu dapat diimplementasikan dengan pembatasan semacam itu. Tabel biasanya menyertakan kolom index rowid tersembunyi yang memberikan akses lebih cepat. Jika database termasuk kolom Integer Primary Key, SQLite biasanya akan mengoptimalkannya dengan memperlakukannya sebagai alias untuk rowid, menyebabkan kontennya disimpan sebagai integer 64-bit yang diketik-ketat dan mengubah perilakunya menjadi agak seperti penambahan otomatis kolom. Versi masa depan dari SQLite mungkin termasuk perintah untuk mengintrospeksi apakah sebuah kolom memiliki perilaku seperti itu dari rowid untuk membedakan kolom ini dari Kunci Primer Integer yang tidak terkunci secara otomatis.
			\item SQLite dengan fungsi Unicode penuh adalah opsional.
			\item Beberapa proses komputer atau utas dapat mengakses basis data yang sama secara bersamaan. Beberapa akses dapat dibaca secara paralel. Akses hanya dapat digunakan jika ada. Jika tidak, akses tulis gagal dengan kode kesalahan (atau dapat dicoba kembali secara otomatis sampai batas waktu dapat dikonfigurasi untuk kedaluwarsa). Akses data ini akan berubah ketika berhadapan dengan tabel sementara. Pembatasan ini dilonggarkan dalam versi 3,7 dari kompilasi write-ahead (WAL) diaktifkan untuk memungkinkan membaca dan pencurian simultan. SQLite versi 3.7.4 pertama kali melihat modul FTS4 tambahan (pencarian teks lengkap), menampilkan perbaikan dalam modul FTS3 yang lebih lama. FTS4 memungkinkan pengguna untuk melakukan teks lengkap pada dokumen yang mirip dengan bagaimana mesin pencari mencari halaman web. Versi 3.8.2 Tambah untuk membuat tabel tanpa rowid, yang dapat memberikan ruang dan peningkatan kinerja. Penguatan tabel umum ditambahkan ke SQLite di versi 3.8.3.
		\end{enumerate}
	\subsection{Perkembangan dan Distribusi}
		\begin{enumerate}
			\item Kode SQLite di-host dengan Fossil, sistem kontrol versi terdistribusi yang dibangun di database SQLite.
			\item Program baris perintah yang berdiri sendiri disediakan dalam distribusi SQLite. Ini dapat digunakan untuk membuat database, menentukan tabel, menyisipkan dan mengubah baris, menjalankan kueri dan mengelola file database SQLite. Ini juga berfungsi sebagai contoh untuk menulis aplikasi yang menggunakan pustaka SQLite.
			\item SQLite menggunakan pengujian regresi otomatis sebelum setiap rilis. Lebih dari 2 juta tes dijalankan sebagai bagian dari verifikasi rilis. Dimulai dengan rilis 10 Agustus 2009 dari SQLite 3.6.17, rilis SQLite memiliki cakupan cabang cakupan 100%, salah satu komponen cakupan kode. Tes dan tes menggunakan domain publik dan kepemilikan parsial.
		\end{enumerate}
		